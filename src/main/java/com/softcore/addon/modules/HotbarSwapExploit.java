package com.softcore.addon.modules;

import com.softcore.addon.SoftcoreAddon;
import meteordevelopment.meteorclient.events.packets.PacketEvent;
import meteordevelopment.meteorclient.events.world.TickEvent;
import meteordevelopment.meteorclient.settings.*;
import meteordevelopment.meteorclient.systems.modules.Module;
import meteordevelopment.meteorclient.utils.player.ChatUtils;
import meteordevelopment.orbit.EventHandler;
import net.minecraft.client.gui.screen.ingame.HandledScreen;
import net.minecraft.network.packet.c2s.play.ClickSlotC2SPacket;
import net.minecraft.network.packet.c2s.play.CloseHandledScreenC2SPacket;

public class HotbarSwapExploit extends Module {
    private final SettingGroup sgGeneral = settings.getDefaultGroup();
    private final SettingGroup sgTiming = settings.createGroup("Timing");

    private final Setting<Boolean> autoCloseAfterSwap = sgGeneral.add(new BoolSetting.Builder()
        .name("auto-close-after-swap")
        .description("Automatically close inventory after hotbar swap")
        .defaultValue(false)
        .build()
    );

    private final Setting<Integer> closeDelayTicks = sgTiming.add(new IntSetting.Builder()
        .name("close-delay-ticks")
        .description("Ticks to wait before auto-closing (0 = instant)")
        .defaultValue(0)
        .min(0)
        .max(10)
        .sliderMax(10)
        .visible(autoCloseAfterSwap::get)
        .build()
    );

    private final Setting<Boolean> blockClosePacket = sgGeneral.add(new BoolSetting.Builder()
        .name("block-close-packet")
        .description("Block the close packet after swap (keeps inventory open server-side)")
        .defaultValue(false)
        .build()
    );

    private final Setting<Boolean> delayClosePacket = sgGeneral.add(new BoolSetting.Builder()
        .name("delay-close-packet")
        .description("Delay close packet after swap")
        .defaultValue(false)
        .build()
    );

    private final Setting<Integer> delayAmount = sgTiming.add(new IntSetting.Builder()
        .name("delay-amount")
        .description("Ticks to delay the close packet")
        .defaultValue(5)
        .min(1)
        .max(40)
        .sliderMax(20)
        .visible(delayClosePacket::get)
        .build()
    );

    private final Setting<Boolean> notifyOnSwap = sgGeneral.add(new BoolSetting.Builder()
        .name("notify")
        .description("Notify when hotbar swap is detected")
        .defaultValue(true)
        .build()
    );

    private boolean swapDetected = false;
    private int ticksUntilClose = 0;
    private CloseHandledScreenC2SPacket delayedClosePacket = null;
    private int delayTicksRemaining = 0;

    public HotbarSwapExploit() {
        super(SoftcoreAddon.CATEGORY, "hotbar-swap-exploit", 
            "Tests Death Chest HOTBAR_SWAP + updateInventory() timing exploit. " +
            "Swap with hotbar keys (1-9) then immediately close before server updates.");
    }

    @Override
    public void onActivate() {
        swapDetected = false;
        ticksUntilClose = 0;
        delayedClosePacket = null;
        delayTicksRemaining = 0;
        info("§eHotbar swap exploit tester activated!");
        info("§71. Swap items using hotbar keys (1-9)");
        info("§72. Module will handle closing/blocking based on settings");
    }

    @EventHandler
    private void onSendPacket(PacketEvent.Send event) {
        // Detect inventory clicks (simplified - includes hotbar swaps)
        if (event.packet instanceof ClickSlotC2SPacket) {
            ClickSlotC2SPacket packet = (ClickSlotC2SPacket) event.packet;
            
            // Note: Use hotbar keys (1-9) on items manually
            swapDetected = true;
            
            if (notifyOnSwap.get()) {
                ChatUtils.info("§6⚡ Inventory CLICK detected! If you used hotbar keys: " +
                    (autoCloseAfterSwap.get() ? "Auto-closing in " + closeDelayTicks.get() + " ticks" : 
                     "Close manually to test exploit"));
            }

            if (autoCloseAfterSwap.get()) {
                ticksUntilClose = closeDelayTicks.get();
            }
        }

        // Handle close packet
        if (event.packet instanceof CloseHandledScreenC2SPacket) {
            if (swapDetected) {
                if (blockClosePacket.get()) {
                    event.cancel();
                    swapDetected = false;
                    if (notifyOnSwap.get()) {
                        ChatUtils.info("§c❌ BLOCKED close packet after swap! Inventory still open server-side!");
                    }
                } else if (delayClosePacket.get()) {
                    event.cancel();
                    delayedClosePacket = (CloseHandledScreenC2SPacket) event.packet;
                    delayTicksRemaining = delayAmount.get();
                    swapDetected = false;
                    if (notifyOnSwap.get()) {
                        ChatUtils.info("§6⏱ DELAYED close packet for " + delayAmount.get() + " ticks!");
                    }
                }
            }
        }
    }

    @EventHandler
    private void onTick(TickEvent.Post event) {
        // Handle auto-close after swap
        if (ticksUntilClose > 0) {
            ticksUntilClose--;
            if (ticksUntilClose == 0 && mc.currentScreen instanceof HandledScreen) {
                mc.player.closeHandledScreen();
                if (notifyOnSwap.get()) {
                    ChatUtils.info("§e✓ Auto-closed after swap!");
                }
                swapDetected = false;
            }
        }

        // Handle delayed close packet
        if (delayedClosePacket != null && delayTicksRemaining > 0) {
            delayTicksRemaining--;
            if (delayTicksRemaining == 0) {
                if (mc.getNetworkHandler() != null) {
                    mc.getNetworkHandler().sendPacket(delayedClosePacket);
                    if (notifyOnSwap.get()) {
                        ChatUtils.info("§a✓ Sent delayed close packet!");
                    }
                }
                delayedClosePacket = null;
            }
        }
    }
}
